<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ±å‡ªçš„èŒèŒç«æŠ€åœº Hand Only Ver. (â‰§â—¡â‰¦)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Comic Sans MS', 'Microsoft YaHei', cursive, sans-serif;
            background-color: #ffd1dc;
            user-select: none;
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #crosshair::before {
            content: 'â¤';
            font-size: 24px;
            color: #ff69b4;
            text-shadow: 0 0 5px #fff;
            position: absolute;
        }
        #crosshair::after {
            content: '';
            width: 60px;
            height: 60px;
            border: 2px dashed rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.5);
            animation: spin 8s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        #score-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #score-board {
            font-size: 28px;
            color: #fff;
            text-shadow: 2px 2px 0px #ff69b4, 0 0 10px #ff1493;
            font-weight: bold;
        }
        #high-score-board {
            font-size: 18px;
            color: #ffd700; 
            text-shadow: 1px 1px 2px #d2691e;
            font-weight: bold;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 6px solid #ff69b4;
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.6);
            pointer-events: auto;
            cursor: pointer;
            color: #d87093;
            min-width: 320px;
        }
        #instructions h1 {
            margin-top: 0;
            font-size: 36px;
            margin-bottom: 10px;
        }
        .key {
            display: inline-block;
            background: #ffebcd;
            padding: 2px 8px;
            border-radius: 5px;
            border: 1px solid #ffa07a;
            color: #ff6347;
            font-weight: bold;
            margin: 0 2px;
        }
        #health-bar-container {
            width: 350px;
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 3px solid #fff;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff9a9e 0%, #ff69b4 50%, #ff1493 100%);
            transition: width 0.2s ease-out; /* åŠ¨ç”»æ›´å¹³æ»‘ */
        }
        #health-text {
            position: absolute;
            width: 100%;
            text-align: center;
            top: 0;
            line-height: 30px;
            color: white;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.6);
        }
        #ammo-tip {
            font-size: 14px;
            color: #ffe4e1;
            text-shadow: 1px 1px 2px #ff1493;
            text-align: right;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="score-container">
            <div id="high-score-board">ğŸ† å†å²æœ€é«˜: <span id="high-score">0</span></div>
            <div id="score-board">çˆ±å¿ƒç§¯åˆ†: <span id="score">0</span> ğŸ’•</div>
        </div>
        <div id="crosshair"></div>
        <div style="align-self: flex-end;">
            <div id="health-bar-container">
                <div id="health-bar"></div>
                <div id="health-text">HP (å‡»æ€å›è¡€!)</div>
            </div>
            <div id="ammo-tip">æŒ‰ä½å·¦é”®è¿å‘ | åªæœ‰æ‰‹æ‰‹äº†å–µ</div>
        </div>
    </div>

    <div id="instructions">
        <h1>(â‰§â—¡â‰¦) èŒèŒç«æŠ€åœº Hand Only</h1>
        <p>ç‚¹å‡»ç”»é¢å¼€å§‹æŒ‘æˆ˜å–µï¼</p>
        <div style="text-align: left; display: inline-block;">
            <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> å…‰é€Ÿç§»åŠ¨</p>
            <p><span class="key">SPACE</span> å¤±é‡è·³è·ƒ</p>
            <p><span class="key">SHIFT</span> è¹²ä¸‹</p>
            <p><span class="key">é•¿æŒ‰å·¦é”®</span> æ— é™è¿å°„</p>
        </div>
        <p style="font-size: 12px; color: #aaa;">è§†é‡æ›´å¼€é˜”äº†å“¦ï¼</p>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // æ±å‡ªçš„å…¨å±€å˜é‡
        let camera, scene, renderer;
        let controls;
        let weapon; 
        let leftHand; // å·¦æ‰‹
        
        // è¿åŠ¨çŠ¶æ€
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let jumpCount = 0; 
        let isCrouching = false;
        let isFiring = false; 

        // ç‰©ç†ä¸æ¸¸æˆå‚æ•°
        let prevTime = performance.now();
        let lastShootTime = 0;
        const SHOOT_DELAY = 100; 
        
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const PLAYER_HEIGHT = 10;
        const PLAYER_SPEED = 1800.0; 
        const PLAYER_JUMP = 120.0; 
        const GRAVITY = 9.8 * 25.0; 
        
        const PLAYER_MAX_HEALTH = 100; 

        // æ¸¸æˆå¯¹è±¡
        let enemies = [];
        let bullets = [];
        let particles = [];
        let obstacles = []; 
        let score = 0;
        let highScore = 0; 
        let playerHealth = PLAYER_MAX_HEALTH;
        let gameActive = false;
        
        const colors = {
            sky: 0xe0ffff,
            ground: 0xfff0f5, 
            obstacle1: 0xaec6cf,
            obstacle2: 0xffb7c5,
            obstacle3: 0xffdac1,
            bunny: 0xffffff,
            bear: 0xcd853f,
            cat: 0x808080,
            skin: 0xffdbac, // è‚¤è‰²
            sleeve: 0xffb7c5 // è¢–å­é¢œè‰²
        };

        init();
        animate();

        function init() {
            const container = document.getElementById('game-container');

            highScore = localStorage.getItem('cuteShooterHighScore') || 0;
            document.getElementById('high-score').innerText = highScore;

            // 1. åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(colors.sky);
            scene.fog = new THREE.Fog(colors.sky, 200, 1200); 

            // 2. ç¯å…‰
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 300, 200);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -500;
            dirLight.shadow.camera.right = 500;
            dirLight.shadow.camera.top = 500;
            dirLight.shadow.camera.bottom = -500;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            scene.add(dirLight);

            // 3. ç©å®¶å¯¹è±¡æ„å»º
            // controls (è´Ÿè´£ Y è½´æ—‹è½¬ å’Œ ä½ç½®ç§»åŠ¨)
            controls = new THREE.Object3D();
            controls.position.set(0, PLAYER_HEIGHT, 0); 
            scene.add(controls);

            // camera (è´Ÿè´£ X è½´æ—‹è½¬ - æŠ¬å¤´ä½å¤´)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000); 
            controls.add(camera);

            // æ·»åŠ ç¬¬ä¸€äººç§°å·¦æ‰‹ (å³æ‰‹æ‹¿æ­¦å™¨)
            createLeftHand();

            // 4. åœ°é¢
            const gridSize = 4000;
            const groundGeo = new THREE.PlaneGeometry(gridSize, gridSize);
            const groundMat = new THREE.MeshPhongMaterial({ color: colors.ground, depthWrite: false });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = - Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(gridSize, 200, 0xffffff, 0xffc0cb);
            scene.add(gridHelper);

            // 5. ç”Ÿæˆåœ°å›¾
            createLevel();

            // 6. æ­¦å™¨ (ç°åœ¨æ˜¯å³æ‰‹æ‹¿ç€)
            createWeapon();

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // äº‹ä»¶ç›‘å¬
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);

            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', function () {
                document.body.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', function () {
                gameActive = (document.pointerLockElement === document.body);
                instructions.style.display = gameActive ? 'none' : 'block';
                if (!gameActive) isFiring = false;
            });
        }

        // æ–°å¢ï¼šåªåˆ›å»ºå·¦æ‰‹ï¼Œä¸åˆ›å»ºèº«ä½“
        function createLeftHand() {
            // å·¦æ‰‹ (ç©ºé—²çš„æ‰‹ï¼Œæ”¾åœ¨ç›¸æœºä¸Šï¼Œç¨å¾®æ‘†åŠ¨)
            const handGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const handMat = new THREE.MeshLambertMaterial({ color: colors.skin });
            leftHand = new THREE.Mesh(handGeo, handMat);
            // è°ƒæ•´ä½ç½®ï¼Œçœ‹èµ·æ¥åƒæ˜¯ä»å±å¹•å·¦ä¸‹è§’ä¼¸å‡ºæ¥çš„
            leftHand.position.set(-1.5, -1.5, -2);
            camera.add(leftHand); // ç»‘å®šåˆ°ç›¸æœºï¼Œè·Ÿç€è§†è§’åŠ¨

            // å·¦è‡‚è¢–å­ (åªæœ‰å‰è‡‚)
            const armGeo = new THREE.CylinderGeometry(0.4, 0.5, 3);
            const armMat = new THREE.MeshLambertMaterial({ color: colors.sleeve });
            const arm = new THREE.Mesh(armGeo, armMat);
            arm.rotation.x = Math.PI / 2;
            arm.position.set(0, 0, 1.5);
            leftHand.add(arm);
        }

        function createLevel() {
            const BOUND = 500;
            createWall(0, 20, -BOUND, BOUND*2, 40, 10, colors.obstacle1); 
            createWall(0, 20, BOUND, BOUND*2, 40, 10, colors.obstacle1);  
            createWall(-BOUND, 20, 0, 10, 40, BOUND*2, colors.obstacle1); 
            createWall(BOUND, 20, 0, 10, 40, BOUND*2, colors.obstacle1);  

            for (let i = 0; i < 150; i++) {
                const w = 15 + Math.random() * 25;
                const h = 10 + Math.random() * 30; 
                const d = 15 + Math.random() * 25;
                const x = (Math.random() - 0.5) * (BOUND * 1.8);
                const z = (Math.random() - 0.5) * (BOUND * 1.8);
                
                if (Math.abs(x) < 30 && Math.abs(z) < 30) continue;

                const color = Math.random() > 0.5 ? colors.obstacle2 : colors.obstacle3;
                createWall(x, h/2, z, w, h, d, color);
            }

            createWall(50, 10, 50, 40, 20, 40, 0xffd700); 
            createWall(-100, 15, -100, 30, 30, 30, 0x87ceeb); 
            createWall(200, 20, 100, 50, 40, 50, 0xff69b4); 
        }

        function createWall(x, y, z, w, h, d, color) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            
            mesh.updateMatrixWorld(true); 
            mesh.geometry.computeBoundingBox();
            const box = new THREE.Box3().setFromObject(mesh);
            obstacles.push(box);
        }

        function createWeapon() {
            weapon = new THREE.Group();
            
            const handleGeo = new THREE.CylinderGeometry(0.15, 0.1, 3, 8);
            const handleMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.rotation.x = Math.PI / 2;
            handle.position.z = 1;
            weapon.add(handle);

            const starGeo = new THREE.IcosahedronGeometry(0.6, 0);
            const starMat = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0xffa500, emissiveIntensity: 0.5 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.z = -0.5; 
            weapon.add(star);

            const wingGeo = new THREE.BoxGeometry(0.1, 0.5, 0.2);
            const wing1 = new THREE.Mesh(wingGeo, new THREE.MeshBasicMaterial({color: 0xffffff}));
            wing1.position.set(0.5, 0, -0.5);
            wing1.rotation.z = -0.5;
            const wing2 = wing1.clone();
            wing2.position.set(-0.5, 0, -0.5);
            wing2.rotation.z = 0.5;
            weapon.add(wing1, wing2);

            // å³æ‰‹æ‹¿ç€æ­¦å™¨
            const handGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const handMat = new THREE.MeshLambertMaterial({ color: colors.skin });
            const rightHand = new THREE.Mesh(handGeo, handMat);
            rightHand.position.set(0, 0, 2.5); // æ¡æŠŠå¤„
            weapon.add(rightHand);

            // å³è‡‚
            const armGeo = new THREE.CylinderGeometry(0.4, 0.5, 4);
            const armMat = new THREE.MeshLambertMaterial({ color: colors.sleeve });
            const arm = new THREE.Mesh(armGeo, armMat);
            arm.rotation.x = Math.PI / 2;
            arm.position.set(0.2, -0.2, 4.5); 
            // ç¨å¾®æ­ªä¸€ç‚¹çœ‹èµ·æ¥è‡ªç„¶
            arm.rotation.z = -0.1;
            weapon.add(arm);

            weapon.position.set(1.2, -1.0, -1.5);
            weapon.rotation.y = -0.1; 
            camera.add(weapon);
        }

        function checkCollision(newPos, radius = 2) {
            for (const obstacleBox of obstacles) {
                if (newPos.x > obstacleBox.min.x - radius && newPos.x < obstacleBox.max.x + radius &&
                    newPos.z > obstacleBox.min.z - radius && newPos.z < obstacleBox.max.z + radius) {
                    
                    if (newPos.y >= obstacleBox.max.y - 2) { 
                         return { collision: false, groundHeight: obstacleBox.max.y };
                    }
                    return { collision: true, groundHeight: 0 };
                }
            }
            return { collision: false, groundHeight: 0 };
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': 
                    if (canJump) {
                        velocity.y += PLAYER_JUMP; 
                        canJump = false;
                        jumpCount = 1;
                    } else if (jumpCount === 1) {
                        velocity.y = PLAYER_JUMP * 1.0; 
                        jumpCount = 2;
                        createParticles(controls.position.clone(), 0x87ceeb, 8); 
                    }
                    break;
                case 'ShiftLeft':
                    if (!isCrouching) {
                        isCrouching = true;
                        camera.position.y = -4; 
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft':
                    if (isCrouching) {
                        isCrouching = false;
                        camera.position.y = 0;
                    }
                    break;
            }
        }

        function onMouseDown(event) {
            if (gameActive && event.button === 0) isFiring = true;
        }
        function onMouseUp(event) {
            if (event.button === 0) isFiring = false;
        }

        function onMouseMove(event) {
            if (gameActive) {
                controls.rotation.y -= event.movementX * 0.002;
                camera.rotation.x -= event.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }

        function shoot() {
            const bulletGeo = new THREE.SphereGeometry(0.6, 8, 8); 
            const bulletMat = new THREE.MeshBasicMaterial({ color: 0xff1493 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);

            const spawnPos = new THREE.Vector3();
            // ä¿®æ­£å­å¼¹å‘å°„ç‚¹ï¼Œç¡®ä¿ä»æ˜Ÿæ˜Ÿå¤´å‡ºæ¥
            weapon.children[1].getWorldPosition(spawnPos); 
            bullet.position.copy(spawnPos);

            const targetPoint = new THREE.Vector3();
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            targetPoint.copy(controls.position).add(new THREE.Vector3(0, isCrouching?6:10, 0)).add(cameraDir.multiplyScalar(10000));

            const bulletDir = new THREE.Vector3().subVectors(targetPoint, spawnPos).normalize();

            bullet.userData = {
                velocity: bulletDir.multiplyScalar(8.0), 
                life: 600 
            };
            
            scene.add(bullet);
            bullets.push(bullet);

            // æ­¦å™¨åååŠ›
            weapon.position.z += 0.3;
            weapon.rotation.x += 0.1;
        }

        function spawnEnemy() {
            if (enemies.length >= 8) return;

            const type = Math.random();
            let enemyMesh, speed, hp;

            if (type < 0.33) { 
                enemyMesh = createSimpleEnemy(colors.bunny, 4.0, 'bunny');
                speed = 0.4; hp = 2; 
            } else if (type < 0.66) { 
                enemyMesh = createSimpleEnemy(colors.bear, 6.0, 'bear');
                speed = 0.2; hp = 4; 
            } else { 
                enemyMesh = createSimpleEnemy(colors.cat, 4.0, 'cat');
                speed = 0.3; hp = 3;
            }

            const angle = Math.random() * Math.PI * 2;
            const dist = 200 + Math.random() * 150; 
            enemyMesh.position.set(
                controls.position.x + Math.cos(angle) * dist,
                50, 
                controls.position.z + Math.sin(angle) * dist
            );

            enemyMesh.userData = { 
                type: 'enemy', 
                health: hp, 
                maxHp: hp, 
                speed: speed, 
                velocityY: 0, 
                onGround: false
            };
            scene.add(enemyMesh);
            enemies.push(enemyMesh);
        }

        function createSimpleEnemy(color, scale, type) {
            const group = new THREE.Group();
            
            // é€»è¾‘ç»„ (ç”¨äºç‰©ç†ä½ç½®)
            const meshContainer = new THREE.Group();
            
            const mat = new THREE.MeshLambertMaterial({ color: color });
            
            // è§†è§‰ Mesh (ç”¨äºè·³è·ƒåŠ¨ç”»)
            const visualGroup = new THREE.Group();
            visualGroup.name = "visual";

            const body = new THREE.Mesh(new THREE.BoxGeometry(scale*1.5, scale*1.5, scale*1.5), mat);
            body.position.y = scale * 0.75;
            visualGroup.add(body);

            if (type === 'bunny') {
                const ear = new THREE.Mesh(new THREE.BoxGeometry(scale*0.25, scale*1.0, scale*0.25), mat);
                ear.position.set(-scale*0.3, scale*1.5, 0);
                const ear2 = ear.clone();
                ear2.position.set(scale*0.3, scale*1.5, 0);
                visualGroup.add(ear, ear2);
            } else if (type === 'bear') {
                const ear = new THREE.Mesh(new THREE.BoxGeometry(scale*0.3, scale*0.3, scale*0.2), mat);
                ear.position.set(-scale*0.6, scale*1.3, 0);
                const ear2 = ear.clone();
                ear2.position.set(scale*0.6, scale*1.3, 0);
                visualGroup.add(ear, ear2);
            }

            const eye = new THREE.Mesh(new THREE.BoxGeometry(scale*0.15, scale*0.15, scale*0.1), new THREE.MeshBasicMaterial({color:0x000000}));
            eye.position.set(-scale*0.3, scale, scale*0.76);
            const eye2 = eye.clone();
            eye2.position.set(scale*0.3, scale, scale*0.76);
            visualGroup.add(eye, eye2);

            meshContainer.add(visualGroup);

            return meshContainer;
        }

        function createParticles(pos, color, count) {
            for(let i=0; i<count; i++) {
                const geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                const mat = new THREE.MeshBasicMaterial({color:color});
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                p.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5)*2, (Math.random()*2), (Math.random()-0.5)*2),
                    life: 40
                };
                scene.add(p);
                particles.push(p);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.05); 

            if (gameActive) {
                // ç®€å•çš„å·¦æ‰‹æ‘†åŠ¨åŠ¨ç”»
                if (leftHand) {
                    leftHand.position.y = -1.5 + Math.sin(time * 0.005) * 0.1;
                    if (moveForward || moveBackward || moveLeft || moveRight) {
                         leftHand.position.z = -2 + Math.cos(time * 0.015) * 0.5; // è·‘åŠ¨æ‘†è‡‚
                    }
                }

                if (isFiring && time - lastShootTime > SHOOT_DELAY) {
                    shoot();
                    lastShootTime = time;
                }

                // --- 1. ç©å®¶ç§»åŠ¨ ---
                velocity.x -= velocity.x * 8.0 * delta;
                velocity.z -= velocity.z * 8.0 * delta;
                velocity.y -= GRAVITY * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const currentSpeed = isCrouching ? PLAYER_SPEED * 0.4 : PLAYER_SPEED;
                
                if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed * delta;
                if (moveLeft || moveRight) velocity.x += direction.x * currentSpeed * delta;

                const oldPosX = controls.position.x;
                controls.translateX(velocity.x * delta * 0.15); 
                let collisionX = checkCollision(controls.position);
                if (collisionX.collision) {
                    controls.position.x = oldPosX; 
                    velocity.x = 0;
                }

                const oldPosZ = controls.position.z;
                controls.translateZ(velocity.z * delta * 0.15);
                let collisionZ = checkCollision(controls.position);
                if (collisionZ.collision) {
                    controls.position.z = oldPosZ;
                    velocity.z = 0;
                }

                controls.position.y += velocity.y * delta;
                
                let groundCheck = checkCollision(controls.position);
                let groundHeight = groundCheck.groundHeight > 0 ? groundCheck.groundHeight : 0;
                
                if (controls.position.y < PLAYER_HEIGHT + groundHeight) {
                    velocity.y = Math.max(0, velocity.y);
                    controls.position.y = PLAYER_HEIGHT + groundHeight;
                    canJump = true;
                    jumpCount = 0;
                }

                // --- 2. æ­¦å™¨åŠ¨ç”» ---
                weapon.position.z += (1 - weapon.position.z) * 0.2; 
                weapon.rotation.x += (0 - weapon.rotation.x) * 0.2;

                // --- 3. å­å¼¹ ---
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.position.add(b.userData.velocity);
                    b.userData.life--;

                    if (b.position.y < 0 || checkCollision(b.position).collision) {
                        createParticles(b.position, 0xffffff, 3);
                        scene.remove(b);
                        bullets.splice(i, 1);
                        continue;
                    }
                    if (b.userData.life <= 0) {
                        scene.remove(b);
                        bullets.splice(i, 1);
                    }
                }

                // --- 4. æ•Œäºº (ä¿®å¤åˆ¤å®šä¸è·³è·ƒå¹²æ‰°) ---
                if (Math.random() < 0.01) spawnEnemy();

                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    
                    e.userData.velocityY -= GRAVITY * delta;
                    let eGroundCheck = checkCollision(e.position, 3.0); 
                    let eGroundHeight = eGroundCheck.groundHeight > 0 ? eGroundCheck.groundHeight : 0;
                    
                    if (e.position.y + e.userData.velocityY * delta < 2 + eGroundHeight) {
                        e.userData.velocityY = 0;
                        e.position.y = 2 + eGroundHeight;
                        e.userData.onGround = true;
                    } else {
                        e.userData.onGround = false;
                    }
                    e.position.y += e.userData.velocityY * delta;

                    const toPlayer = new THREE.Vector3().subVectors(controls.position, e.position);
                    // ä¿®æ­£ï¼šé«˜åº¦å·®è®¡ç®—è¦ç®—ä¸Šç©å®¶çš„èº«ä½“é«˜åº¦
                    // ç©å®¶ä¸­å¿ƒåœ¨ controls.position (y=10), æ•Œäººä¸­å¿ƒåœ¨ y=2~4
                    // æˆ‘ä»¬åˆ¤å®šè„šåº•æ¿å·®è·
                    const playerFeetY = controls.position.y - PLAYER_HEIGHT;
                    const enemyFeetY = e.position.y - 2; // ç®€ç•¥ä¼°ç®—
                    const heightDiff = Math.abs(playerFeetY - enemyFeetY);
                    
                    toPlayer.y = 0;
                    const dist = toPlayer.length();
                    
                    const pushDir = toPlayer.clone().normalize();

                    let collisionDist = 6.0;
                    if(e.userData.maxHp > 4) collisionDist = 9.0; 

                    // ä¿®å¤æ”»å‡»åˆ¤å®šï¼šå‚ç›´è·ç¦»åˆ¤å®šæ”¾å®½åˆ° 10 (è¶³å¤Ÿè¦†ç›–è·³è·ƒå’Œé«˜å°è¾¹ç¼˜)
                    // ä¹‹å‰æ˜¯6ï¼Œå¦‚æœæ•Œäººè·³èµ·æ¥å¯èƒ½å°±æ‰“ä¸åˆ°äº†
                    // ç°åœ¨åªè¦æ°´å¹³å¤Ÿè¿‘ï¼Œä¸”å‚ç›´é«˜åº¦å·®ä¸ç®—å¤ªç¦»è°±ï¼ˆæ¯”å¦‚çœŸçš„åœ¨é«˜å¡”é¡¶ç«¯ï¼‰å°±èƒ½æ‰“åˆ°
                    // ä½†è¦é¿å…éš”ç€æ¥¼å±‚æ‰“äººï¼Œæ‰€ä»¥è¿˜æ˜¯ä¿ç•™ä¸€å®šçš„é™åˆ¶
                    if (dist < collisionDist + 2 && heightDiff < 12) { 
                        playerHealth -= 1; 
                        document.getElementById('health-bar').style.width = (playerHealth / PLAYER_MAX_HEALTH * 100) + '%';
                        
                        velocity.x += pushDir.x * 600; 
                        velocity.z += pushDir.z * 600;

                        e.position.sub(pushDir.multiplyScalar(2.0));
                    } else {
                        const oldPos = e.position.clone();
                        e.position.add(pushDir.multiplyScalar(e.userData.speed));
                        
                        let wallCheck = checkCollision(e.position, 3.0);
                        if (wallCheck.collision && e.position.y < wallCheck.groundHeight) {
                            e.position.copy(oldPos); 
                            if (e.userData.onGround) {
                                e.userData.velocityY = PLAYER_JUMP * 1.2; 
                                e.userData.onGround = false;
                            }
                        }
                        // AI è¿½è¸ªè·³è·ƒï¼šå¦‚æœç©å®¶åœ¨ä¸Šé¢ï¼Œå°±è·³
                        if ((controls.position.y - PLAYER_HEIGHT) > e.position.y + 5 && e.userData.onGround && Math.random() < 0.05) {
                             e.userData.velocityY = PLAYER_JUMP * 1.5;
                             e.userData.onGround = false;
                        }
                        
                        e.lookAt(new THREE.Vector3(controls.position.x, e.position.y, controls.position.z));
                    }

                    // è§†è§‰è·³è·ƒåŠ¨ç”» (åˆ†ç¦»ç‰©ç†å’Œè§†è§‰)
                    const visual = e.getObjectByName("visual");
                    if (visual) {
                        visual.position.y = Math.abs(Math.sin(time * 0.01 + e.id)) * 1.0;
                    }

                    for (let j = bullets.length - 1; j >= 0; j--) {
                        let hitDist = 7.0; 
                        if(e.userData.maxHp > 4) hitDist = 10.0;

                        if (e.position.distanceTo(bullets[j].position) < hitDist) {
                            e.userData.health--;
                            createParticles(bullets[j].position, 0xffff00, 2);
                            scene.remove(bullets[j]);
                            bullets.splice(j, 1);
                            
                            e.position.sub(pushDir.multiplyScalar(1.0));

                            if (e.userData.health <= 0) {
                                createParticles(e.position, 0xff69b4, 15);
                                scene.remove(e);
                                enemies.splice(i, 1);
                                score += 100;
                                
                                playerHealth = Math.min(playerHealth + PLAYER_MAX_HEALTH * 0.1, PLAYER_MAX_HEALTH);
                                document.getElementById('health-bar').style.width = (playerHealth / PLAYER_MAX_HEALTH * 100) + '%';

                                if (score > highScore) {
                                    highScore = score;
                                    localStorage.setItem('cuteShooterHighScore', highScore);
                                    document.getElementById('high-score').innerText = highScore;
                                }
                                document.getElementById('score').innerText = score;
                                break;
                            }
                        }
                    }
                }

                // --- 5. ç²’å­ ---
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].position.add(particles[i].userData.vel);
                    particles[i].userData.life--;
                    particles[i].scale.multiplyScalar(0.9);
                    if (particles[i].userData.life <= 0) {
                        scene.remove(particles[i]);
                        particles.splice(i, 1);
                    }
                }

                // --- 6. æ¸¸æˆç»“æŸ ---
                if (playerHealth <= 0) {
                    playerHealth = PLAYER_MAX_HEALTH;
                    score = 0;
                    document.getElementById('health-bar').style.width = '100%';
                    document.getElementById('score').innerText = '0';
                    controls.position.set(0, PLAYER_HEIGHT + 20, 0); 
                    velocity.set(0, 0, 0);
                    enemies.forEach(e => scene.remove(e));
                    enemies = [];
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>