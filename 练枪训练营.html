<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>FPS ç»ƒæªé¦† - æµªæ¼«ç‰¹è®­ Pro (å®Œç¾ä¿®å¤ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
            background: #87CEEB; /* å¤©ç©ºè“ */
        }
        
        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* åŠ¨æ€åå­—å‡†æ˜Ÿ */
        #crosshair-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transform: translate(-50%, -50%);
        }

        /* å‡†å¿ƒçº¿æ¡å…¬å…±æ ·å¼ */
        .ch-part {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
            transition: transform 0.1s ease-out; /* åŠ¨æ€æ”¶ç¼©åŠ¨ç”» */
        }

        /* ä¸Šä¸‹å·¦å³å››æ¡çº¿ */
        .ch-top    { width: 2px; height: 10px; left: -1px; bottom: 5px; } 
        .ch-bottom { width: 2px; height: 10px; left: -1px; top: 5px; }
        .ch-left   { width: 10px; height: 2px; right: 5px; top: -1px; }
        .ch-right  { width: 10px; height: 2px; left: 5px; top: -1px; }

        /* ä¸­å¿ƒçº¢ç‚¹ */
        .ch-dot { 
            position: absolute;
            width: 4px; height: 4px; 
            background: #ff5555; 
            border-radius: 50%; 
            left: -2px; top: -2px;
            z-index: 10; 
            box-shadow: 0 0 2px white;
        }

        /* æ­¦å™¨é¢æ¿ */
        #weapon-panel {
            position: absolute;
            bottom: 30px;
            right: 30px;
            text-align: right;
            color: #333;
            text-shadow: 1px 1px 0px rgba(255,255,255,0.5);
        }
        #weapon-name { font-size: 28px; font-weight: bold; color: #ff69b4; }
        #ammo-display { font-size: 48px; font-family: 'Courier New', monospace; font-weight: bold; color: #333; }
        #reserve-ammo { font-size: 24px; color: #666; }

        /* ç”Ÿå‘½å€¼é¢æ¿ */
        #health-panel {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: flex;
            align-items: center;
            color: #333;
            text-shadow: 1px 1px 0px rgba(255,255,255,0.5);
        }
        #hp-icon {
            font-size: 40px;
            color: #ff5555;
            margin-right: 15px;
            font-weight: bold;
        }
        #hp-value {
            font-size: 48px;
            font-family: 'Impact', sans-serif;
            letter-spacing: 2px;
        }

        /* æ€»åˆ†é¢æ¿ */
        #score-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            font-size: 24px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.6);
            padding: 10px 20px;
            border-radius: 15px;
            border-left: 5px solid #ff69b4;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* å‡»æ€åé¦ˆ */
        #kill-feed {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 350px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        .kill-msg {
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.9) 100%);
            color: #333;
            padding: 8px 15px;
            margin-bottom: 5px;
            border-radius: 8px;
            font-size: 16px;
            display: flex;
            align-items: center;
            animation: fadeIn 0.3s ease-out;
            border-right: 4px solid #ff69b4;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .headshot-icon {
            color: #ff0000;
            font-size: 20px;
            margin: 0 5px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #fff;
        }
        .kill-streak {
            color: #ff9900;
            font-weight: bold;
            font-style: italic;
            margin-left: 10px;
            font-size: 18px;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }

        #interaction-prompt {
            position: absolute;
            top: 65%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            background: rgba(255, 105, 180, 0.8);
            padding: 8px 16px;
            border-radius: 20px;
            display: none;
            border: 2px solid #fff;
            box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4);
        }

        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top-color: #ff3333;
            border-right-color: #ff3333;
            opacity: 0;
            transition: opacity 0.05s;
        }

        #blocker {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 999;
            backdrop-filter: blur(8px);
        }
        #instructions {
            width: 600px;
            padding: 40px;
            background-color: rgba(255, 255, 255, 0.95);
            color: #444;
            text-align: center;
            border-radius: 20px;
            border: 4px solid #ffb6c1;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255, 182, 193, 0.5);
        }
        h1 { margin-top: 0; color: #ff69b4; text-transform: uppercase; letter-spacing: 2px; }
        .key { background: #fff; padding: 4px 10px; border-radius: 8px; border: 2px solid #87CEEB; font-family: monospace; color: #555; font-weight: bold; margin: 0 2px; box-shadow: 0 2px 0 #87CEEB; }
        p { margin: 15px 0; line-height: 1.5; color: #666; }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>ğŸ’– æµªæ¼«ç»ƒæªç‰¹è®­ Pro ğŸ’–</h1>
            <p>ç‚¹å‡»å±å¹•å¼€å§‹ / é”å®šé¼ æ ‡</p>
            <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> ç§»åŠ¨ (çœŸäººæ¯”ä¾‹)</p>
            <p><span class="key">SPACE</span> è·³è·ƒ | <span class="key">SHIFT</span> è¹²ä¸‹ (æé«˜ç²¾åº¦)</p>
            <p><span class="key">1</span> æ­¥æª (å·¦é”®å°„å‡»/å³é”®åˆºåˆ€) | <span class="key">2</span> æ‰‹æª</p>
            <p><span class="key">3</span> å†›åˆ€ (æŒ‰ä½å·¦/å³é”®è¿å‡») | <span class="key">4</span> çˆ±å¿ƒé›·</p>
            <p><span class="key">R</span> æ¢å¼¹ | <span class="key">E</span> è¡¥ç»™</p>
        </div>
    </div>

    <div id="ui-layer">
        <div id="crosshair-container">
            <div class="ch-part ch-top" id="ch-top"></div>
            <div class="ch-part ch-bottom" id="ch-bottom"></div>
            <div class="ch-part ch-left" id="ch-left"></div>
            <div class="ch-part ch-right" id="ch-right"></div>
            <div class="ch-dot"></div>
        </div>
        <div id="hit-marker"></div>
        <div id="interaction-prompt">æŒ‰ [E] è¡¥ç»™å¼¹è¯</div>
        
        <div id="score-panel">
            ğŸ’– å‡»æ€æ•°: <span id="total-kills">0</span>
        </div>

        <div id="kill-feed"></div>

        <div id="health-panel">
            <div id="hp-icon">ğŸ’—</div>
            <div id="hp-value">100</div>
        </div>

        <div id="weapon-panel">
            <div id="weapon-name">çªå‡»æ­¥æª</div>
            <div>
                <span id="ammo-display">30</span> / <span id="reserve-ammo">60</span>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/PointerLockControls.js';

        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            moveSpeed: 10.0,     
            runSpeed: 16.0,      
            walkSpeed: 5.0,      
            crouchSpeed: 4.0,
            jumpForce: 12.0,     
            doubleJumpForce: 6.0,
            gravity: 30.0,
            playerHeight: 1.8,
            crouchHeight: 1.0,
            targetCount: 15,
            respawnTime: 3000,
            mannequinScale: 1.0
        };

        // --- å˜é‡å®šä¹‰ ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isCrouching = false, isWalking = false;
        
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let jumpCount = 0; 

        // æ¸¸æˆç»Ÿè®¡
        let totalKills = 0;
        let killStreak = 0;
        let lastKillTime = 0;

        // æ­¦å™¨ç³»ç»Ÿ
        const WEAPONS = { RIFLE: 0, PISTOL: 1, KNIFE: 2, GRENADE: 3 };
        let currentWeaponIdx = WEAPONS.RIFLE;
        let lastShotTime = 0;
        let grenadeHoldTime = 0; 
        let grenadeReady = true; 

        // å¼€ç«/æ”»å‡»çŠ¶æ€æ ‡å¿—
        let isFiring = false;
        let isMeleeAttacking = false; // è¿‘æˆ˜æŒ‰é”®çŠ¶æ€
        let meleeButton = 0; // 0: Left, 2: Right
        let isReloading = false;

        // æ­¦å™¨æ•°æ®
        const weaponData = [
            { 
                name: "çªå‡»æ­¥æª", 
                mag: 30, reserve: 90, maxMag: 30, 
                damage: { head: 100, body: 34, leg: 26 }, 
                rate: 100, 
                // ä¿®å¤ï¼šç»™æ­¥æªå¢åŠ é‡å‡»(åˆºåˆ€)é¢‘ç‡ï¼Œä¸åŒ•é¦–é‡å‡»ä¸€è‡´
                heavyRate: 800,
                range: 200, 
                recoil: { kick: 0.015, kickH: 0.004, recovery: 3.5 }, 
                modelScale: { x: 1, y: 1, z: 1 },
                posOffset: { x: 0.25, y: -0.25, z: -0.5 },
                type: 'auto'
            },
            { 
                name: "æˆ˜æœ¯æ‰‹æª", 
                mag: 12, reserve: 24, maxMag: 12, 
                damage: { head: 100, body: 51, leg: 34 }, 
                rate: 150, 
                range: 100, 
                recoil: { kick: 0.05, kickH: 0.01, recovery: 5.0 }, 
                modelScale: { x: 1, y: 1, z: 1 }, 
                posOffset: { x: 0.2, y: -0.2, z: -0.4 },
                type: 'semi'
            },
            { 
                name: "å†›ç”¨åŒ•é¦–", 
                mag: 0, reserve: 0, maxMag: 0, 
                damage: { head: 100, body: 51, leg: 34 }, 
                heavyDamage: 100, 
                rate: 400,  
                heavyRate: 800, // é‡å‡»/åˆºåˆ€æ€»è€—æ—¶
                range: 3.5, 
                modelScale: { x: 1, y: 1, z: 1 },
                posOffset: { x: 0.25, y: -0.25, z: -0.4 },
                type: 'melee'
            },
            { 
                name: "çˆ±å¿ƒæ‰‹é›·", 
                mag: 3, reserve: 0, maxMag: 3,
                damage: { center: 200, min: 30 }, 
                range: 25, 
                modelScale: { x: 1, y: 1, z: 1 }, 
                posOffset: { x: 0.2, y: -0.3, z: -0.4 },
                type: 'throw'
            }
        ];

        let targets = [];
        let projectiles = []; 
        let tempEntities = []; 
        let weaponMesh; 
        let supplyZone = { x: 0, z: 20, radius: 3 }; 
        let recoilOffset = 0; 

        // é©¬å¡é¾™é…è‰²
        const PASTEL_COLORS = [0xFFB7B2, 0xFFDAC1, 0xE2F0CB, 0xB5EAD7, 0xC7CEEA, 0xFF9AA2];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 150);

            const light = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.9);
            scene.add(light);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(20, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            scene.add(dirLight);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ';

            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject()); 
            controls.getObject().position.set(0, CONFIG.playerHeight, 25);

            createLevel();
            createClouds();
            createWeaponMesh(WEAPONS.RIFLE); 

            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => { blocker.style.display = 'none'; });
            controls.addEventListener('unlock', () => { blocker.style.display = 'flex'; });

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            for(let i=0; i<CONFIG.targetCount; i++) spawnTarget();
            switchWeapon(0);
        }

        function createLevel() {
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x90EE90, roughness: 0.9 });
            const targetZone = new THREE.Mesh(new THREE.BoxGeometry(60, 1, 80), floorMat);
            targetZone.position.set(0, -0.5, -30); targetZone.receiveShadow = true;
            scene.add(targetZone);

            const shootZone = new THREE.Mesh(new THREE.BoxGeometry(60, 1, 20), floorMat);
            shootZone.position.set(0, -0.5, 20); shootZone.receiveShadow = true;
            scene.add(shootZone);

            const step = new THREE.Mesh(new THREE.BoxGeometry(60, 0.2, 4), new THREE.MeshStandardMaterial({ color: 0xFFB6C1 }));
            step.position.set(0, 0.1, 10); step.receiveShadow = true; step.castShadow = true;
            scene.add(step);

            const wallMat = new THREE.MeshStandardMaterial({ color: 0xFFE4E1, roughness: 0.8 });
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(64, 20, 1), wallMat); backWall.position.set(0, 10, -70.5); scene.add(backWall);
            const sideGeo = new THREE.BoxGeometry(1, 20, 102);
            const leftWall = new THREE.Mesh(sideGeo, wallMat); leftWall.position.set(-30.5, 10, -20); scene.add(leftWall);
            const rightWall = new THREE.Mesh(sideGeo, wallMat); rightWall.position.set(30.5, 10, -20); scene.add(rightWall);
            const frontWall = new THREE.Mesh(new THREE.BoxGeometry(64, 20, 1), wallMat); frontWall.position.set(0, 10, 30.5); scene.add(frontWall);

            const ring = new THREE.Mesh(new THREE.RingGeometry(2.5, 3, 32), new THREE.MeshBasicMaterial({ color: 0xFFD700, side: THREE.DoubleSide }));
            ring.rotation.x = -Math.PI / 2; ring.position.set(supplyZone.x, 0.02, supplyZone.z); scene.add(ring);
        }

        function createClouds() {
            const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5, flatShading: true });
            for (let i = 0; i < 15; i++) {
                const cloud = new THREE.Group();
                const blocks = 3 + Math.floor(Math.random() * 4);
                for (let j = 0; j < blocks; j++) {
                    const size = 4 + Math.random() * 3;
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), cloudMat);
                    mesh.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*4, (Math.random()-0.5)*6);
                    mesh.rotation.y = Math.random() * Math.PI;
                    cloud.add(mesh);
                }
                cloud.position.set((Math.random()-0.5)*150, 30+Math.random()*20, -20+(Math.random()-0.5)*100);
                scene.add(cloud);
            }
        }

        function spawnTarget() {
            const x = (Math.random() - 0.5) * 50;
            const z = (Math.random() * 70) - 65;
            const scale = CONFIG.mannequinScale;
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            const mainColor = PASTEL_COLORS[Math.floor(Math.random() * PASTEL_COLORS.length)];
            const matHead = new THREE.MeshStandardMaterial({ color: 0xffeebb }); 
            const matBody = new THREE.MeshStandardMaterial({ color: mainColor });
            const matLegs = new THREE.MeshStandardMaterial({ color: 0x555555 });

            const legGeo = new THREE.BoxGeometry(0.25 * scale, 0.9 * scale, 0.25 * scale);
            const legL = new THREE.Mesh(legGeo, matLegs); legL.position.set(-0.15*scale, 0.45*scale, 0);
            const legR = new THREE.Mesh(legGeo, matLegs); legR.position.set(0.15*scale, 0.45*scale, 0);
            legL.userData = legR.userData = { part: 'leg', parent: group }; group.add(legL, legR);

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6 * scale, 0.7 * scale, 0.3 * scale), matBody);
            body.position.set(0, 1.25 * scale, 0); body.userData = { part: 'body', parent: group }; group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25 * scale, 16, 16), matHead);
            head.position.set(0, 1.75 * scale, 0); head.userData = { part: 'head', parent: group }; group.add(head);

            group.userData = { hp: 100, isDead: false }; scene.add(group); targets.push(group);
        }

        function createWeaponMesh(type) {
            if (weaponMesh) { controls.getObject().remove(weaponMesh); weaponMesh = null; }
            const data = weaponData[type];
            const group = new THREE.Group();

            const gunMetal = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });
            const silver = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.2, metalness: 1.0 });
            const wood = new THREE.MeshStandardMaterial({ color: 0x8B5A2B }); 
            const pink = new THREE.MeshStandardMaterial({ color: 0xFF69B4 });

            if (type === WEAPONS.RIFLE) {
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), gunMetal); 
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.5), gunMetal); 
                barrel.rotation.x = Math.PI/2; barrel.position.z = -0.55;
                const mag = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.2, 0.1), gunMetal);
                mag.position.set(0, -0.15, 0); mag.rotation.x = 0.2;
                const stock = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.3), wood); stock.position.z = 0.45;
                const bayonet = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.04, 0.3), silver); 
                bayonet.position.set(0, -0.06, -0.7);
                group.add(body, barrel, mag, stock, bayonet);
            } else if (type === WEAPONS.PISTOL) {
                const slide = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.3), silver);
                const grip = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.15, 0.1), wood);
                grip.position.set(0, -0.1, 0.1); grip.rotation.x = 0.1;
                group.add(slide, grip);
            } else if (type === WEAPONS.KNIFE) {
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.2), wood);
                handle.rotation.x = Math.PI/2; handle.position.z = 0.2;
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.05, 0.4), silver); blade.position.z = -0.1;
                group.add(handle, blade);
            } else if (type === WEAPONS.GRENADE) {
                const ball = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), pink);
                const pin = new THREE.Mesh(new THREE.TorusGeometry(0.03, 0.005, 8, 16), silver);
                pin.position.set(0, 0.1, 0); group.add(ball, pin);
            }

            group.scale.set(data.modelScale.x, data.modelScale.y, data.modelScale.z);
            group.position.set(data.posOffset.x, data.posOffset.y, data.posOffset.z);
            if (type === WEAPONS.RIFLE) group.rotation.y = 0;
            controls.getObject().add(group); weaponMesh = group;
        }

        function switchWeapon(idx) {
            currentWeaponIdx = idx;
            createWeaponMesh(idx);
            updateUI();
            isReloading = false;
            grenadeHoldTime = 0;
            grenadeReady = true; 
            recoilOffset = 0;
            isFiring = false;
            isMeleeAttacking = false;
        }

        function updateUI() {
            const w = weaponData[currentWeaponIdx];
            document.getElementById('weapon-name').innerText = w.name;
            document.getElementById('ammo-display').innerText = w.mag;
            document.getElementById('reserve-ammo').innerText = (currentWeaponIdx === WEAPONS.GRENADE) ? '-' : w.reserve;
        }

        function recordKill(isHeadshot) {
            totalKills++;
            document.getElementById('total-kills').innerText = totalKills;
            const now = performance.now();
            if (now - lastKillTime < 5000) killStreak++; else killStreak = 1;
            lastKillTime = now;

            const w = weaponData[currentWeaponIdx];
            const feed = document.getElementById('kill-feed');
            const msg = document.createElement('div');
            msg.className = 'kill-msg';
            let headshotHtml = isHeadshot ? '<span class="headshot-icon">âŒ–</span>' : '';
            let streakText = killStreak > 1 ? `<span class="kill-streak">x${killStreak}</span>` : "";
            msg.innerHTML = `${w.name} ${headshotHtml} â” äººå¶ ${streakText}`;
            feed.prepend(msg); 
            setTimeout(() => { msg.style.opacity = '0'; setTimeout(() => msg.remove(), 300); }, 3000);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) { velocity.y = CONFIG.jumpForce; canJump = false; jumpCount = 1; } else if (jumpCount === 1) { velocity.y = CONFIG.doubleJumpForce; jumpCount = 2; } break;
                case 'ShiftLeft': isCrouching = true; break;
                case 'CapsLock': isWalking = true; break;
                case 'Digit1': switchWeapon(WEAPONS.RIFLE); break;
                case 'Digit2': switchWeapon(WEAPONS.PISTOL); break;
                case 'Digit3': switchWeapon(WEAPONS.KNIFE); break;
                case 'Digit4': switchWeapon(WEAPONS.GRENADE); break;
                case 'KeyR': reload(); break;
                case 'KeyE': checkResupply(); break;
            }
        }
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isCrouching = false; break;
                case 'CapsLock': isWalking = false; break;
            }
        }

        function onMouseDown(e) {
            if (!controls.isLocked) return;
            const w = weaponData[currentWeaponIdx];

            if (currentWeaponIdx === WEAPONS.RIFLE && e.button === 0) isFiring = true;
            if (currentWeaponIdx === WEAPONS.RIFLE && e.button === 2) {
                isMeleeAttacking = true;
                meleeButton = 2; 
            }
            if (currentWeaponIdx === WEAPONS.PISTOL && e.button === 0) fireWeapon();
            if (currentWeaponIdx === WEAPONS.KNIFE) {
                if(e.button === 0 || e.button === 2) {
                    isMeleeAttacking = true;
                    meleeButton = e.button;
                }
            }
            if (currentWeaponIdx === WEAPONS.GRENADE && e.button === 0 && grenadeReady) {
                grenadeHoldTime = performance.now();
                if(weaponMesh) weaponMesh.visible = false; 
            }
        }

        function onMouseUp(e) {
            if (currentWeaponIdx === WEAPONS.RIFLE && e.button === 0) isFiring = false;
            if (currentWeaponIdx === WEAPONS.RIFLE && e.button === 2) isMeleeAttacking = false;
            if (currentWeaponIdx === WEAPONS.KNIFE && (e.button === 0 || e.button === 2)) isMeleeAttacking = false;
            if (currentWeaponIdx === WEAPONS.GRENADE && e.button === 0 && grenadeHoldTime > 0) {
                throwGrenade(); grenadeHoldTime = 0;
            }
        }

        function applyRecoil(w) {
            const kick = w.recoil.kick * (1 + Math.random() * 0.2); 
            const cam = controls.getObject();
            cam.rotation.x += kick; 
            recoilOffset += kick; 
            const kickH = (Math.random() - 0.5) * (w.recoil.kickH || 0.005); 
            cam.rotation.y += kickH; 
            if(weaponMesh) {
                weaponMesh.position.z += 0.15; 
                weaponMesh.rotation.x += 0.2; 
                setTimeout(()=> { if(weaponMesh) weaponMesh.rotation.x -= 0.2; }, 50);
            }
        }

        function fireWeapon() {
            const w = weaponData[currentWeaponIdx];
            const now = performance.now();
            if (now - lastShotTime < w.rate || w.mag <= 0 || isReloading) {
                if (w.mag <= 0 && !isReloading) reload();
                return;
            }
            lastShotTime = now;
            w.mag--;
            updateUI();
            applyRecoil(w);
            // å°„å‡»æ—¶ä¸æ˜¯è¿‘æˆ˜ï¼Œæ‰€ä»¥ isMelee = false
            checkHitScan(w.damage.body, w.range, false);
        }

        // ä¿®å¤ï¼šcheckHitScan å¢åŠ  isMelee å‚æ•°
        function checkHitScan(baseDamage, range, isMelee = false) {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = range;
            let targetsMesh = [];
            targets.forEach(t => { if(!t.userData.isDead) t.traverse(c => { if(c.isMesh) targetsMesh.push(c); }) });
            scene.traverse(c => { if(c.isMesh && c.parent === scene) targetsMesh.push(c); });

            const intersects = raycaster.intersectObjects(targetsMesh);
            if (intersects.length > 0) {
                const hit = intersects[0];
                createHitEffect(hit.point);
                const data = hit.object.userData;
                if (data && data.parent) {
                    let dmg = baseDamage;
                    let isHeadshot = false;
                    const w = weaponData[currentWeaponIdx];
                    
                    // å¦‚æœæ˜¯è¿‘æˆ˜æ”»å‡»ï¼Œç›´æ¥ä½¿ç”¨åŸºç¡€ä¼¤å®³(100)ï¼Œä¸è®¡ç®—éƒ¨ä½å€ç‡
                    // å¦‚æœæ˜¯å°„å‡»ï¼Œåˆ™è®¡ç®—å€ç‡
                    if (!isMelee && w.type !== 'melee') { 
                        if (data.part === 'head') { dmg = w.damage.head; isHeadshot = true; }
                        else if (data.part === 'leg') dmg = w.damage.leg;
                    } 
                    
                    takeDamage(data.parent, dmg, isHeadshot); 
                    showHitMarker();
                }
            }
        }

        function processMeleeLogic() {
            const now = performance.now();
            const w = weaponData[currentWeaponIdx];
            
            let isHeavy = false;
            if (currentWeaponIdx === WEAPONS.RIFLE && meleeButton === 2) isHeavy = true;
            if (currentWeaponIdx === WEAPONS.KNIFE && meleeButton === 2) isHeavy = true;

            let rate = isHeavy ? w.heavyRate : w.rate;
            
            if (now - lastShotTime < rate) return;
            lastShotTime = now; 

            const windupTime = isHeavy ? 300 : 100; 
            const recoveryTime = isHeavy ? 500 : 300; 

            if (weaponMesh) {
                if (isHeavy) {
                    weaponMesh.position.z += 0.2; 
                    weaponMesh.rotation.z = -0.2; 
                    weaponMesh.rotation.x = -0.2;
                } else {
                    weaponMesh.position.z += 0.1;
                    weaponMesh.position.x += 0.1;
                }
            }

            setTimeout(() => {
                if (weaponMesh) {
                    if (isHeavy) {
                        weaponMesh.position.z -= 0.6; 
                        weaponMesh.rotation.z = 0;
                        weaponMesh.rotation.x = 0;
                    } else {
                        weaponMesh.position.z -= 0.3;
                        weaponMesh.position.x -= 0.2;
                    }
                }

                const dmg = isHeavy ? 100 : 50;
                // ä¿®å¤ï¼šè¿‘æˆ˜æ”»å‡»æ—¶ä¼ å…¥ trueï¼Œå¼ºåˆ¶é€ æˆå…¨é¢ä¼¤å®³
                checkHitScan(dmg, w.range, true);

                setTimeout(() => {
                    if(weaponMesh) {
                        const resetX = w.posOffset.x;
                        const resetZ = w.posOffset.z;
                        weaponMesh.position.set(resetX, w.posOffset.y, resetZ);
                        weaponMesh.rotation.set(0,0,0);
                    }
                }, recoveryTime);

            }, windupTime);
        }

        function throwGrenade() {
            const w = weaponData[WEAPONS.GRENADE];
            if (w.mag <= 0 || !grenadeReady) return;
            w.mag--; updateUI();
            grenadeReady = false; 
            const ball = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshStandardMaterial({color: 0xFF69B4}));
            ball.position.copy(controls.getObject().position);
            const dir = new THREE.Vector3(); controls.getDirection(dir);
            const vel = dir.multiplyScalar(25); vel.y += 5;
            scene.add(ball); projectiles.push({ mesh: ball, vel: vel, life: 3.0 });
            setTimeout(() => {
                if (currentWeaponIdx === WEAPONS.GRENADE && w.mag > 0) {
                    grenadeReady = true;
                    if(weaponMesh) weaponMesh.visible = true;
                }
            }, 1000);
        }

        function checkResupply() {
            const p = controls.getObject().position;
            if (Math.sqrt((p.x - supplyZone.x)**2 + (p.z - supplyZone.z)**2) < supplyZone.radius) {
                weaponData.forEach(w => { 
                    w.mag = w.maxMag; 
                    if (w.type !== 'throw') w.reserve = w.maxMag * 3; 
                }); 
                updateUI();
                const tip = document.getElementById('interaction-prompt');
                tip.innerText = "è¡¥ç»™å®Œæˆï¼"; tip.style.color = "#fff"; tip.style.backgroundColor = "#32CD32";
                setTimeout(() => { tip.innerText = "æŒ‰ [E] è¡¥ç»™å¼¹è¯"; tip.style.color = "#fff"; tip.style.backgroundColor = "rgba(255, 105, 180, 0.8)"; }, 2000);
            }
        }

        function reload() {
            if (isReloading) return;
            isReloading = true;
            if(weaponMesh) weaponMesh.rotation.x = -0.5;
            setTimeout(() => {
                const w = weaponData[currentWeaponIdx];
                if (w.type !== 'throw') {
                    const need = w.maxMag - w.mag;
                    if (w.reserve >= need) { w.mag += need; w.reserve -= need; } else { w.mag += w.reserve; w.reserve = 0; }
                }
                isReloading = false; if(weaponMesh) weaponMesh.rotation.x = 0; updateUI();
            }, 1500);
        }

        function createHitEffect(pos) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.05,0.05), new THREE.MeshBasicMaterial({color:0xff0000}));
            p.position.copy(pos); scene.add(p); setTimeout(()=>scene.remove(p), 500);
        }

        function showHitMarker() {
            const el = document.getElementById('hit-marker'); el.style.opacity = 1; setTimeout(() => el.style.opacity = 0, 100);
        }

        function takeDamage(target, dmg, isHeadshot=false) {
            target.userData.hp -= dmg;
            if (target.userData.hp <= 0 && !target.userData.isDead) {
                target.userData.isDead = true;
                target.rotation.x = -Math.PI/2; target.position.y = 0.5;
                recordKill(isHeadshot);
                setTimeout(() => { scene.remove(target); targets = targets.filter(t => t !== target); spawnTarget(); }, CONFIG.respawnTime);
            }
        }

        function explodeGrenade(pos) {
            const w = weaponData[WEAPONS.GRENADE];
            targets.forEach(t => { 
                if(!t.userData.isDead && t.position.distanceTo(pos) < w.range) takeDamage(t, 200, false);
            });
            const boom = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 16), new THREE.MeshBasicMaterial({color:0xFF1493, transparent:true, opacity:0.8}));
            boom.position.copy(pos); scene.add(boom); tempEntities.push({mesh: boom, life: 0.5});
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateCrosshairGap(speed) {
            let gap = 5; 

            if (isCrouching) {
                gap = 0; 
            } else {
                if (speed > 1) gap += 4; 
                if (speed > 8) gap += 4; 
                if (isFiring || isMeleeAttacking) gap += 4; 
            }

            document.getElementById('ch-top').style.transform = `translateY(-${gap}px)`;
            document.getElementById('ch-bottom').style.transform = `translateY(${gap}px)`;
            document.getElementById('ch-left').style.transform = `translateX(-${gap}px)`;
            document.getElementById('ch-right').style.transform = `translateX(${gap}px)`;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const dt = Math.min((time - prevTime) / 1000, 0.1);
            prevTime = time;

            if (controls.isLocked) {
                const camObj = controls.getObject();
                camObj.rotation.z = 0;

                const speed = (isCrouching ? CONFIG.crouchSpeed : (isWalking ? CONFIG.walkSpeed : CONFIG.moveSpeed));
                velocity.x -= velocity.x * 10.0 * dt;
                velocity.z -= velocity.z * 10.0 * dt;
                velocity.y -= CONFIG.gravity * dt;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * speed * 10.0 * dt;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * 10.0 * dt;

                controls.moveRight(-velocity.x * dt);
                controls.moveForward(-velocity.z * dt);
                camObj.position.y += velocity.y * dt;

                let groundY = 0;
                if (camObj.position.z > 8 && camObj.position.z < 12 && Math.abs(camObj.position.x) < 30) {
                    groundY = 0.2;
                }

                const playerY = camObj.position.y;
                const eyeHeight = isCrouching ? CONFIG.crouchHeight : CONFIG.playerHeight;

                if (playerY < groundY + eyeHeight) {
                    velocity.y = 0;
                    camObj.position.y = groundY + eyeHeight;
                    canJump = true; jumpCount = 0;
                }

                if (isFiring && currentWeaponIdx === WEAPONS.RIFLE) fireWeapon();

                if (isMeleeAttacking && (currentWeaponIdx === WEAPONS.KNIFE || currentWeaponIdx === WEAPONS.RIFLE)) {
                    processMeleeLogic();
                }

                const currentSpeed = Math.sqrt(velocity.x**2 + velocity.z**2);
                updateCrosshairGap(currentSpeed);

                if (recoilOffset > 0 && !isFiring) {
                    const recovery = weaponData[currentWeaponIdx].recoil.recovery * dt; 
                    const amount = Math.min(recoilOffset, recovery);
                    camObj.rotation.x -= amount; 
                    recoilOffset -= amount;
                }

                if (weaponMesh) {
                    const w = weaponData[currentWeaponIdx];
                    
                    if (w.type === 'auto' || w.type === 'semi' || w.type === 'throw') {
                        const targetZ = w.posOffset.z;
                        const maxRecoilZ = targetZ + 0.4; 
                        if (weaponMesh.position.z > maxRecoilZ) {
                            weaponMesh.position.z = maxRecoilZ;
                        }
                        if (weaponMesh.position.z > targetZ) {
                            weaponMesh.position.z -= 4 * dt; 
                            if (weaponMesh.position.z < targetZ) weaponMesh.position.z = targetZ;
                        }
                    } else if (w.type === 'melee') {
                        if (!isMeleeAttacking && (now - lastShotTime > 1000)) {
                             if (Math.abs(weaponMesh.position.z - w.posOffset.z) > 0.01) {
                                 weaponMesh.position.z = w.posOffset.z;
                                 weaponMesh.position.x = w.posOffset.x;
                                 weaponMesh.rotation.set(0,0,0);
                             }
                        }
                    }
                }
                
                const p = camObj.position;
                const prompt = document.getElementById('interaction-prompt');
                if (Math.sqrt((p.x - supplyZone.x)**2 + (p.z - supplyZone.z)**2) < supplyZone.radius) {
                    if(prompt.style.display==='none' && !prompt.innerText.includes('è¡¥ç»™å®Œæˆ')) prompt.style.display = 'block';
                } else {
                   if(!prompt.innerText.includes('è¡¥ç»™å®Œæˆ')) prompt.style.display = 'none';
                }
            }

            projectiles.forEach((p, i) => {
                p.vel.y -= CONFIG.gravity * dt;
                p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                p.life -= dt;
                if (p.mesh.position.y < 0.1) { p.mesh.position.y = 0.1; p.vel.multiplyScalar(0.5); }
                if (p.life <= 0) { explodeGrenade(p.mesh.position); scene.remove(p.mesh); projectiles.splice(i, 1); }
            });

            tempEntities.forEach((e, i) => {
                e.life -= dt;
                e.mesh.scale.multiplyScalar(1.1);
                e.mesh.material.opacity = e.life * 2;
                if (e.life <= 0) { scene.remove(e.mesh); tempEntities.splice(i, 1); }
            });

            renderer.render(scene, camera);
        }
        const now = performance.now();
    </script>
</body>
</html>