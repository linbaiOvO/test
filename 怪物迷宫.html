<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Abyss - ä¸Šå¸æ¨¡å¼ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Microsoft YaHei', sans-serif; }
        
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* å‡†å¿ƒ */
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 4px white;
        }

        /* ç»“ç®—ç•Œé¢ */
        #result-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            opacity: 0;
            pointer-events: auto;
            transition: opacity 0.5s;
            z-index: 50;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px; left: 20px;
            color: #ddd;
            font-size: 18px;
            z-index: 10;
            background: rgba(0,0,0,0.6);
            padding: 15px 25px;
            border-radius: 8px;
            border-left: 4px solid #00ffff;
        }
        .objective { font-size: 22px; font-weight: bold; color: #fff; margin-bottom: 5px; display: block; }
        .sub-text { font-size: 14px; color: #aaa; }
        
        #status-bar {
            position: absolute;
            bottom: 30px; width: 100%;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            z-index: 10;
        }

        /* èœå• */
        #menu {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #111;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ccc;
            z-index: 30;
            text-align: center;
        }
        h1 { font-size: 4rem; letter-spacing: 5px; color: #fff; text-shadow: 0 0 20px #00ffff; margin-bottom: 20px; font-family: 'Impact', sans-serif; }
        
        .btn-group { display: flex; gap: 20px; margin-top: 30px; }

        .btn {
            color: #fff; 
            border: 2px solid #fff; 
            padding: 15px 40px; 
            cursor: pointer; 
            font-size: 1.2rem;
            font-weight: bold;
            transition: all 0.2s;
            background: rgba(255,255,255,0.1);
            text-transform: uppercase;
            min-width: 200px;
        }
        .btn:hover { background: #fff; color: #000; box-shadow: 0 0 20px #fff; }
        
        .btn-god { border-color: #ffd700; color: #ffd700; }
        .btn-god:hover { background: #ffd700; color: #000; box-shadow: 0 0 20px #ffd700; }

        /* å¿ƒè·³ç‰¹æ•ˆ */
        #heartbeat-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%);
            pointer-events: none;
            z-index: 5;
            display: none;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="crosshair"></div>
    <div id="heartbeat-overlay"></div>

    <div id="hud">
        <span class="objective" id="obj-text">ç›®æ ‡: æ”¶é›†æ ¸å¿ƒ (<span id="score-val" style="color:#00ffff">0</span>/5)</span>
        <div class="sub-text">æ‰‹ç”µç­’ [F]: <span id="light-val">å¼€å¯</span></div>
    </div>
    
    <div id="status-bar" style="color: #00ff00;">å®‰å…¨</div>

    <div id="result-screen">
        <h1 id="result-title">æ¸¸æˆç»“æŸ</h1>
        <p id="result-desc" style="color: #ccc; font-size: 1.5rem; margin-bottom: 20px;">ä½ è¢«æŠ“ä½äº†...</p>
        <button class="btn" onclick="location.reload()">é‡æ–°æŒ‘æˆ˜</button>
    </div>

    <div id="menu">
        <h1>THE ABYSS</h1>
        <div style="background: rgba(255,255,255,0.05); padding: 30px; border-radius: 10px; text-align: left; max-width: 600px;">
            <p style="color:#00ffff; font-weight:bold; font-size: 1.2rem;">ğŸ† æ¸¸æˆè¯´æ˜ï¼š</p>
            <p>åœ°å›¾ä¸Šæœ‰ <span style="color:#00ffff; font-weight:bold;">10 ä¸ª</span> èƒ½é‡æ ¸å¿ƒï¼Œæ”¶é›† <span style="color:#fff; font-weight:bold;">5 ä¸ª</span> å³å¯è·èƒœã€‚</p>
            <br>
            <p style="color:#ff5555; font-weight:bold; font-size: 1.2rem;"âš ï¸ ç”Ÿå­˜æŒ‡å—ï¼š</p>
            <p>1. çœ‹åˆ°çº¢å…‰ç«‹åˆ» <span style="color:#fff; border:1px solid #fff; padding:0 5px;">æŒ‰ F å…³ç¯</span> å¹¶é™æ­¢ã€‚</p>
            <p>2. æ‰‹ç”µç­’å·²å‡çº§ï¼Œå¯ç…§äº®è¿œæ–¹ã€‚</p>
        </div>
        
        <div class="btn-group">
            <button class="btn" id="start-btn">å¼€å§‹æ¸¸æˆ<br><span style="font-size:0.8rem; font-weight:normal;">(ç”Ÿå­˜æ¨¡å¼)</span></button>
            <button class="btn btn-god" id="god-btn">ä¸Šå¸æ¨¡å¼<br><span style="font-size:0.8rem; font-weight:normal;">(å…¨äº®/æ— æ•Œ/æ¸¸è§ˆ)</span></button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- å‚æ•° ---
        const WALL_HEIGHT = 5;
        const MOVE_SPEED = 8.0;
        const ENEMY_SPEED_IDLE = 2.0;
        const ENEMY_SPEED_CHASE = 5.5; 
        
        // æ‰‹ç”µç­’åŠ å¼º
        const FLASHLIGHT_INTENSITY = 8.0; // äº®åº¦ç¿»å€
        const FLASHLIGHT_DIST = 100;      // è·ç¦»ç¿»å€
        const FLASHLIGHT_ANGLE = Math.PI / 3.5; // è§’åº¦æ›´å®½

        const MAZE_SIZE = 21; 
        const CELL_SIZE = 5;
        const TOTAL_ITEMS = 10; // æ ¸å¿ƒæ•°é‡å¢åŠ åˆ°10

        // --- å…¨å±€å˜é‡ ---
        let camera, scene, renderer;
        let prevTime = performance.now();
        let isLocked = false;
        let isGameOver = false;
        let isGodMode = false; // ä¸Šå¸æ¨¡å¼å¼€å…³

        const input = { w:0, a:0, s:0, d:0 };
        let isFlashlightOn = true;
        let score = 0;

        const walls = [];
        const items = []; 
        const enemies = []; 
        let flashlight, flashlightTarget;
        let ambientLight;

        // UI
        let scoreVal, lightVal, statusBar, resultScreen, resultTitle, resultDesc, menu, heartbeatOverlay, objText;

        window.addEventListener('load', () => {
            scoreVal = document.getElementById('score-val');
            lightVal = document.getElementById('light-val');
            statusBar = document.getElementById('status-bar');
            resultScreen = document.getElementById('result-screen');
            resultTitle = document.getElementById('result-title');
            resultDesc = document.getElementById('result-desc');
            menu = document.getElementById('menu');
            heartbeatOverlay = document.getElementById('heartbeat-overlay');
            objText = document.getElementById('obj-text');

            init();
            animate();
        });

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020202);
            scene.fog = new THREE.Fog(0x020202, 2, 40); // é›¾æ¨å¾—æ›´è¿œ

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 150);
            camera.position.y = 1.7;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // åŸºç¡€ç¯å¢ƒå…‰ (ç¨å¾®è°ƒäº®ä¸€ç‚¹ç‚¹ï¼Œé˜²æ­¢å…¨é»‘èµ°è·¯æ’å¢™)
            ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);

            // å¼ºåŠ›æ‰‹ç”µç­’
            flashlight = new THREE.SpotLight(0xffffff, FLASHLIGHT_INTENSITY);
            flashlight.angle = FLASHLIGHT_ANGLE;
            flashlight.penumbra = 0.3;
            flashlight.decay = 1.0; // è¡°å‡å‡å°
            flashlight.distance = FLASHLIGHT_DIST;
            flashlight.castShadow = true;
            
            flashlight.position.set(0,0,0); 
            flashlightTarget = new THREE.Object3D();
            flashlightTarget.position.set(0, 0, -1);
            
            camera.add(flashlight);
            camera.add(flashlightTarget);
            flashlight.target = flashlightTarget;
            scene.add(camera);

            generateMaze();
            spawnItems(TOTAL_ITEMS); // ç”Ÿæˆ10ä¸ª
            spawnEnemies(5);
            setupEvents();
        }

        // --- æ¨¡å¼åˆ‡æ¢ ---
        function startGame(godMode) {
            isGodMode = godMode;
            document.body.requestPointerLock();

            if (isGodMode) {
                // ä¸Šå¸æ¨¡å¼è®¾ç½®
                ambientLight.intensity = 1.5; // å…¨å›¾å¤§äº®
                scene.fog.density = 0; // ç§»é™¤é›¾
                scene.fog.far = 1000;
                
                objText.innerText = "ä¸Šå¸æ¨¡å¼ (è‡ªç”±å‚è§‚)";
                objText.style.color = "#ffd700";
                statusBar.innerText = "è§‚å¯Ÿè€…æ¨¡å¼ï¼šæ€ªç‰©æ— æ³•çœ‹è§ä½ ï¼Œæ— æ³•æ‹¾å–ç‰©å“";
                statusBar.style.color = "#ffd700";
                
                // å…³é—­æ‰‹ç”µç­’ä»¥å…å¹²æ‰°
                isFlashlightOn = false;
                flashlight.intensity = 0;
                lightVal.innerText = "å·²ç¦ç”¨";
            } else {
                // æ™®é€šæ¨¡å¼è®¾ç½®
                ambientLight.intensity = 0.1;
                scene.fog.far = 40;
                objText.innerHTML = 'ç›®æ ‡: æ”¶é›†æ ¸å¿ƒ (<span id="score-val" style="color:#00ffff">0</span>/5)';
                // é‡æ–°è·å–ä¸€ä¸‹score elementå› ä¸ºinnerHTMLé‡ç½®äº†
                scoreVal = document.getElementById('score-val'); 
                
                isFlashlightOn = true;
                flashlight.intensity = FLASHLIGHT_INTENSITY;
                lightVal.innerText = "å¼€å¯";
            }
        }

        function generateMaze() {
            const map = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(1));

            function carve(x, y) {
                map[x][y] = 0;
                const dirs = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);
                for (let [dx, dy] of dirs) {
                    const nx = x + dx, ny = y + dy;
                    if (nx > 0 && nx < MAZE_SIZE && ny > 0 && ny < MAZE_SIZE && map[nx][ny] === 1) {
                        map[x + dx/2][y + dy/2] = 0;
                        carve(nx, ny);
                    }
                }
            }
            carve(1, 1);
            map[1][1] = 0; 

            const wallGeo = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            const edgeGeo = new THREE.EdgesGeometry(wallGeo);
            const edgeMat = new THREE.LineBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.3 });

            const floorGeo = new THREE.PlaneGeometry(MAZE_SIZE * CELL_SIZE, MAZE_SIZE * CELL_SIZE);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            const ceil = new THREE.Mesh(floorGeo, floorMat);
            ceil.rotation.x = Math.PI / 2;
            ceil.position.y = WALL_HEIGHT;
            scene.add(ceil);

            for (let i = 0; i < MAZE_SIZE; i++) {
                for (let j = 0; j < MAZE_SIZE; j++) {
                    if (map[i][j] === 1) {
                        const wall = new THREE.Mesh(wallGeo, wallMat);
                        wall.position.set((i - MAZE_SIZE/2) * CELL_SIZE, WALL_HEIGHT/2, (j - MAZE_SIZE/2) * CELL_SIZE);
                        scene.add(wall);
                        
                        const edges = new THREE.LineSegments(edgeGeo, edgeMat);
                        wall.add(edges);

                        wall.userData = { 
                            minX: wall.position.x - CELL_SIZE/2, maxX: wall.position.x + CELL_SIZE/2,
                            minZ: wall.position.z - CELL_SIZE/2, maxZ: wall.position.z + CELL_SIZE/2
                        };
                        walls.push(wall);
                    }
                }
            }
            camera.position.set((1 - MAZE_SIZE/2) * CELL_SIZE, 1.7, (1 - MAZE_SIZE/2) * CELL_SIZE);
        }

        function spawnItems(count) {
            const geo = new THREE.OctahedronGeometry(0.4);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            
            for(let i=0; i<count; i++) {
                const item = new THREE.Mesh(geo, mat);
                let valid = false;
                let tries = 0;
                while(!valid && tries < 100) {
                    tries++;
                    const rx = (Math.random() - 0.5) * MAZE_SIZE * CELL_SIZE * 0.8;
                    const rz = (Math.random() - 0.5) * MAZE_SIZE * CELL_SIZE * 0.8;
                    let hitWall = false;
                    for(const w of walls) {
                        if (Math.abs(w.position.x - rx) < CELL_SIZE/1.8 && Math.abs(w.position.z - rz) < CELL_SIZE/1.8) {
                            hitWall = true; break;
                        }
                    }
                    if(!hitWall) {
                        item.position.set(rx, 1.2, rz); 
                        valid = true;
                    }
                }
                if(valid) {
                    const light = new THREE.PointLight(0x00ffff, 3, 15);
                    item.add(light);
                    item.userData = { isItem: true, floatOffset: Math.random() * 100 };
                    scene.add(item);
                    items.push(item);
                }
            }
        }

        function spawnEnemies(count) {
            const bodyGeo = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const eyeGeo = new THREE.SphereGeometry(0.1);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            for(let i=0; i<count; i++) {
                const enemy = new THREE.Group();
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.6;
                enemy.add(body);

                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.15, 1.0, 0.35);
                enemy.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.15, 1.0, 0.35);
                enemy.add(rightEye);
                
                const eyeLight = new THREE.PointLight(0xff0000, 2, 8);
                eyeLight.position.set(0, 1.0, 0.5);
                enemy.add(eyeLight);

                let valid = false;
                let tries = 0;
                while(!valid && tries < 100) {
                    tries++;
                    const rx = (Math.random() - 0.5) * MAZE_SIZE * CELL_SIZE * 0.8;
                    const rz = (Math.random() - 0.5) * MAZE_SIZE * CELL_SIZE * 0.8;
                    if (Math.abs(rx - camera.position.x) > 20 || Math.abs(rz - camera.position.z) > 20) {
                        let hitWall = false;
                        for(const w of walls) {
                            if (Math.abs(w.position.x - rx) < CELL_SIZE/2 && Math.abs(w.position.z - rz) < CELL_SIZE/2) {
                                hitWall = true; break;
                            }
                        }
                        if (!hitWall) {
                            enemy.position.set(rx, 0.5, rz);
                            valid = true;
                        }
                    }
                }
                if(valid) {
                    enemy.userData = {
                        state: 'patrol',
                        targetPos: new THREE.Vector3(),
                        speed: ENEMY_SPEED_IDLE,
                        changeDirTimer: 0
                    };
                    scene.add(enemy);
                    enemies.push(enemy);
                }
            }
        }

        function setupEvents() {
            const onKey = (code, v) => {
                switch(code) {
                    case 'KeyW': input.w = v; break;
                    case 'KeyS': input.s = v; break;
                    case 'KeyA': input.a = v; break;
                    case 'KeyD': input.d = v; break;
                    case 'KeyF': if (v) toggleFlashlight(); break;
                }
            };
            document.addEventListener('keydown', e => onKey(e.code, 1));
            document.addEventListener('keyup', e => onKey(e.code, 0));

            document.addEventListener('mousemove', e => {
                if(!isLocked || isGameOver) return;
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-0.6, Math.min(0.6, camera.rotation.x)); 
                camera.rotation.order = 'YXZ';
            });

            // æ™®é€šå¼€å§‹
            document.getElementById('start-btn').addEventListener('click', () => {
                startGame(false);
            });

            // ä¸Šå¸æ¨¡å¼å¼€å§‹
            document.getElementById('god-btn').addEventListener('click', () => {
                startGame(true);
            });

            document.addEventListener('pointerlockchange', () => {
                isLocked = (document.pointerLockElement === document.body);
                menu.style.display = isLocked ? 'none' : 'flex';
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function toggleFlashlight() {
            // ä¸Šå¸æ¨¡å¼ç¦ç”¨æ‰‹ç”µç­’åˆ‡æ¢
            if (isGodMode) return;

            isFlashlightOn = !isFlashlightOn;
            flashlight.intensity = isFlashlightOn ? FLASHLIGHT_INTENSITY : 0;
            lightVal.innerText = isFlashlightOn ? "å¼€å¯" : "å…³é—­";
            lightVal.style.color = isFlashlightOn ? "#fff" : "#444";
            
            if (isFlashlightOn) {
                 statusBar.innerText = "æ‰‹ç”µç­’å¼€å¯ï¼šå°å¿ƒï¼Œæ€ªç‰©èƒ½çœ‹è§ä½ ï¼";
                 statusBar.style.color = "#ffaa00";
            } else {
                 statusBar.innerText = "éšè”½æ¨¡å¼ï¼šæ€ªç‰©å¾ˆéš¾å‘ç°ä½ ã€‚";
                 statusBar.style.color = "#00ff00";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isGameOver) {
                renderer.render(scene, camera);
                return;
            }
            const time = performance.now();
            const delta = Math.min((time - prevTime)/1000, 0.1);
            prevTime = time;

            if (isLocked) {
                updatePlayer(delta);
                updateItems(time);
                updateEnemies(delta);
            }
            renderer.render(scene, camera);
        }

        function updatePlayer(delta) {
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            camDir.y = 0; camDir.normalize();
            const camRight = new THREE.Vector3(-camDir.z, 0, camDir.x);

            const moveVec = new THREE.Vector3();
            if (input.w) moveVec.add(camDir);
            if (input.s) moveVec.sub(camDir);
            if (input.d) moveVec.add(camRight);
            if (input.a) moveVec.sub(camRight);
            moveVec.normalize(); 

            const moveDist = MOVE_SPEED * delta;
            const nextX = camera.position.x + moveVec.x * moveDist;
            const nextZ = camera.position.z + moveVec.z * moveDist;

            let collideX = false;
            let collideZ = false;
            const playerRadius = 0.4; 

            for(const w of walls) {
                const d = w.userData;
                if (nextX + playerRadius > d.minX && nextX - playerRadius < d.maxX &&
                    camera.position.z + playerRadius > d.minZ && camera.position.z - playerRadius < d.maxZ) collideX = true;
                if (camera.position.x + playerRadius > d.minX && camera.position.x - playerRadius < d.maxX &&
                    nextZ + playerRadius > d.minZ && nextZ - playerRadius < d.maxZ) collideZ = true;
            }
            if (!collideX) camera.position.x = nextX;
            if (!collideZ) camera.position.z = nextZ;
        }

        function updateItems(time) {
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.position.y = 1.2 + Math.sin(time * 0.003 + item.userData.floatOffset) * 0.2;
                item.rotation.y += 0.02;
                
                // ä¸Šå¸æ¨¡å¼æ— æ³•æ‹¾å–
                if (!isGodMode) {
                    if (camera.position.distanceTo(item.position) < 2.5) {
                        scene.remove(item);
                        items.splice(i, 1);
                        score++;
                        scoreVal.innerText = score;
                        
                        statusBar.innerText = `æ”¶é›†èƒ½é‡æ ¸å¿ƒ (${score}/5) - å¹²å¾—å¥½ï¼`;
                        statusBar.style.color = "#00ffff";
                        setTimeout(() => {
                             if(!isGameOver && !isGodMode) statusBar.innerText = "ç»§ç»­å¯»æ‰¾...";
                        }, 2000);
    
                        if (score >= 5) endGame(true);
                    }
                }
            }
        }

        function updateEnemies(delta) {
            // ä¸Šå¸æ¨¡å¼æ€ªç‰©ä¸è¿½äººï¼Œåªå·¡é€»
            let maxDangerLevel = 0;

            for (const e of enemies) {
                let detected = false;
                let dist = 0;

                if (!isGodMode) {
                    dist = camera.position.distanceTo(e.position);

                    // AI è§†è§‰
                    if (isFlashlightOn) {
                        const camDir = new THREE.Vector3();
                        camera.getWorldDirection(camDir);
                        const toEnemy = new THREE.Vector3().subVectors(e.position, camera.position).normalize();
                        const angle = camDir.angleTo(toEnemy);
                        
                        if (angle < Math.PI / 3) { 
                            detected = true;
                            e.userData.speed = ENEMY_SPEED_CHASE * 1.2; 
                        } else if (dist < 10) {
                            detected = true;
                            e.userData.speed = ENEMY_SPEED_CHASE;
                        }
                    } else {
                        if (dist < 4.0) {
                            detected = true;
                            e.userData.speed = ENEMY_SPEED_CHASE * 0.8;
                        }
                    }
                }

                if (detected) {
                    e.userData.state = 'chase';
                    e.lookAt(camera.position.x, 0.6, camera.position.z);
                    const dir = new THREE.Vector3().subVectors(camera.position, e.position).normalize();
                    e.position.add(dir.multiplyScalar(e.userData.speed * delta));
                } else {
                    e.userData.state = 'patrol';
                    e.userData.changeDirTimer -= delta;
                    if (e.userData.changeDirTimer <= 0) {
                        e.userData.targetPos.set((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2).normalize();
                        e.userData.changeDirTimer = 2 + Math.random() * 3;
                    }
                    const nextPos = e.position.clone().add(e.userData.targetPos.clone().multiplyScalar(ENEMY_SPEED_IDLE * delta));
                    if (Math.abs(nextPos.x) < MAZE_SIZE * CELL_SIZE / 2 && Math.abs(nextPos.z) < MAZE_SIZE * CELL_SIZE / 2) {
                        e.position.copy(nextPos);
                    } else {
                        e.userData.changeDirTimer = 0;
                    }
                    const lookTarget = e.position.clone().add(e.userData.targetPos);
                    e.lookAt(lookTarget.x, 0.6, lookTarget.z);
                }

                if (!isGodMode) {
                    if (dist < 15) {
                        const danger = 1 - (dist / 15);
                        if (danger > maxDangerLevel) maxDangerLevel = danger;
                    }
                    if (dist < 1.0) endGame(false);
                }
            }

            if (maxDangerLevel > 0 && !isGodMode) {
                heartbeatOverlay.style.display = 'block';
                const opacity = 0.1 + maxDangerLevel * 0.6;
                heartbeatOverlay.style.background = `radial-gradient(circle, transparent 50%, rgba(255,0,0,${opacity}) 100%)`;
                if (maxDangerLevel > 0.5) {
                    statusBar.innerText = "è­¦å‘Šï¼æ€ªç‰©å°±åœ¨é™„è¿‘ï¼";
                    statusBar.style.color = "#ff0000";
                }
            } else {
                heartbeatOverlay.style.display = 'none';
            }
        }

        function endGame(win) {
            if(isGameOver) return;
            isGameOver = true;
            document.exitPointerLock();

            resultScreen.style.display = 'flex';
            setTimeout(() => resultScreen.style.opacity = 1, 50);

            if (win) {
                resultTitle.innerText = "é€ƒè„±æˆåŠŸ";
                resultTitle.style.color = "#00ffff";
                resultDesc.innerText = "ä½ æˆåŠŸå¸¦å›äº†æ‰€æœ‰èƒ½é‡æ ¸å¿ƒã€‚";
            } else {
                resultTitle.innerText = "ä»»åŠ¡å¤±è´¥";
                resultTitle.style.color = "#ff0000";
                resultDesc.innerText = "ä½ åœ¨é»‘æš—ä¸­è¿·å¤±äº†...";
            }
        }
    </script>
</body>
</html>