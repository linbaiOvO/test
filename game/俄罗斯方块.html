<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>经典俄罗斯方块</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            touch-action: manipulation; /* 优化移动端触摸响应 */
        }
        .grid-bg {
            background-image:
                linear-gradient(to right, rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes line-clear-animation {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(0); }
        }
        .line-clear {
            animation: line-clear-animation 0.3s ease-out forwards;
        }
    </style>
</head>
<body class="bg-slate-900 text-white flex items-center justify-center min-h-screen p-4">

    <div class="flex flex-col md:flex-row gap-4 md:gap-8 items-start">
        <!-- 主游戏区域 -->
        <div class="relative w-[300px] h-[600px] bg-black rounded-lg shadow-2xl shadow-cyan-500/20">
            <canvas id="gameCanvas" width="300" height="600"></canvas>
            <div id="overlay" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center text-center p-4 rounded-lg hidden fade-in">
                <h2 id="overlay-title" class="text-4xl font-bold text-cyan-400 mb-4">游戏结束</h2>
                <p id="overlay-text" class="text-lg mb-6">再接再厉！</p>
                <button id="start-button" class="bg-cyan-500 text-slate-900 font-bold py-3 px-8 rounded-lg hover:bg-cyan-400 transition text-xl">开始游戏</button>
            </div>
        </div>

        <!-- 信息和控制区域 -->
        <div class="w-full md:w-48 flex flex-col gap-4">
            <div class="bg-slate-800 p-4 rounded-lg text-center">
                <h1 class="text-3xl font-bold text-cyan-400 mb-2">俄罗斯方块</h1>
            </div>

            <div class="bg-slate-800 p-4 rounded-lg">
                <h2 class="font-bold text-slate-400 mb-1">得分</h2>
                <p id="score" class="text-2xl font-bold">0</p>
                <h2 class="font-bold text-slate-400 mt-2 mb-1">最高分</h2>
                <p id="best-score" class="text-xl font-bold">0</p>
            </div>

            <div class="bg-slate-800 p-4 rounded-lg">
                <h2 class="font-bold text-slate-400 mb-1">行数</h2>
                <p id="lines" class="text-2xl font-bold">0</p>
                <h2 class="font-bold text-slate-400 mt-2 mb-1">等级</h2>
                <p id="level" class="text-2xl font-bold">1</p>
            </div>

            <div class="bg-slate-800 p-4 rounded-lg">
                <h2 class="font-bold text-slate-400 mb-2 text-center">下一个</h2>
                <div class="flex justify-center items-center h-24">
                    <canvas id="nextCanvas" width="120" height="120"></canvas>
                </div>
            </div>

             <div class="bg-slate-800 p-4 rounded-lg text-sm text-slate-400">
                <h2 class="font-bold text-white mb-2">控制</h2>
                <p><strong class="text-cyan-400">← →:</strong> 移动</p>
                <p><strong class="text-cyan-400">↑:</strong> 旋转</p>
                <p><strong class="text-cyan-400">↓:</strong> 加速</p>
                <p><strong class="text-cyan-400">空格:</strong> 瞬落</p>
                <p><strong class="text-cyan-400">P:</strong> 暂停</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');

        const scoreEl = document.getElementById('score');
        const bestScoreEl = document.getElementById('best-score');
        const linesEl = document.getElementById('lines');
        const levelEl = document.getElementById('level');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayText = document.getElementById('overlay-text');
        const startButton = document.getElementById('start-button');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;

        const COLORS = [
            null,
            '#FF0D72', // T
            '#0DC2FF', // I
            '#0DFF72', // O
            '#F538FF', // L
            '#FF8E0D', // J
            '#FFE138', // S
            '#3877FF', // Z
        ];

        const SHAPES = [
            [],
            [[0, 1, 0], [1, 1, 1], [0, 0, 0]], // T
            [[0, 0, 0, 0], [2, 2, 2, 2], [0, 0, 0, 0], [0, 0, 0, 0]], // I
            [[3, 3], [3, 3]], // O
            [[0, 0, 4], [4, 4, 4], [0, 0, 0]], // L
            [[5, 0, 0], [5, 5, 5], [0, 0, 0]], // J
            [[0, 6, 6], [6, 6, 0], [0, 0, 0]], // S
            [[7, 7, 0], [0, 7, 7], [0, 0, 0]], // Z
        ];

        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        let score = 0;
        let bestScore = localStorage.getItem('tetrisBestScore') || 0;
        let lines = 0;
        let level = 1;
        let piece, nextPiece;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let isPaused = false;
        let isGameOver = false;
        let animationFrameId;

        class Piece {
            constructor(shape, ctx) {
                this.shape = shape;
                this.ctx = ctx;
                this.color = COLORS[this.shape.flat().find(v => v > 0)];
                this.x = 3;
                this.y = 0;
            }

            draw() {
                this.ctx.fillStyle = this.color;
                this.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value > 0) {
                            this.ctx.fillRect((this.x + x) * BLOCK_SIZE, (this.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        }
                    });
                });
            }

            move(p) {
                this.x = p.x;
                this.y = p.y;
                this.shape = p.shape;
            }
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            for(let i = 1; i < COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * BLOCK_SIZE, 0);
                ctx.lineTo(i * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                ctx.stroke();
            }
            for(let i = 1; i < ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * BLOCK_SIZE);
                ctx.lineTo(COLS * BLOCK_SIZE, i * BLOCK_SIZE);
                ctx.stroke();
            }

            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        ctx.fillStyle = COLORS[value];
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });
        }

        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            const shape = nextPiece.shape;
            const color = nextPiece.color;
            const shapeSize = shape.length;
            const blockSize = 20;
            const xOffset = (nextCanvas.width - shapeSize * blockSize) / 2;
            const yOffset = (nextCanvas.height - shapeSize * blockSize) / 2;

            nextCtx.fillStyle = color;
            shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        nextCtx.fillRect(xOffset + x * blockSize, yOffset + y * blockSize, blockSize, blockSize);
                    }
                });
            });
        }

        function resetGame() {
            board.forEach(row => row.fill(0));
            score = 0;
            lines = 0;
            level = 1;
            isGameOver = false;
            isPaused = false;
            dropInterval = 1000;
            
            const shapeIndex = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
            piece = new Piece(SHAPES[shapeIndex], ctx);
            
            const nextShapeIndex = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
            nextPiece = new Piece(SHAPES[nextShapeIndex], nextCtx);

            updateUI();
            drawNextPiece();
            overlay.classList.add('hidden');
        }

        function play() {
            resetGame();
            lastTime = 0;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        function gameLoop(time = 0) {
            if (isPaused || isGameOver) return;

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            if (dropCounter > dropInterval) {
                pieceDrop();
            }

            drawBoard();
            piece.draw();

            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function pieceDrop() {
            const p = { ...piece, y: piece.y + 1 };
            if (isValidMove(p)) {
                piece.move(p);
            } else {
                lockPiece();
                clearLines();
                spawnNewPiece();
            }
            dropCounter = 0;
        }

        function isValidMove(p) {
            return p.shape.every((row, dy) => {
                return row.every((value, dx) => {
                    if (value === 0) return true;
                    const newX = p.x + dx;
                    const newY = p.y + dy;
                    return (
                        newX >= 0 && newX < COLS &&
                        newY < ROWS &&
                        (!board[newY] || board[newY][newX] === 0)
                    );
                });
            });
        }

        function lockPiece() {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value > 0) {
                        if (piece.y + y < 0) {
                            gameOver();
                            return;
                        }
                        board[piece.y + y][piece.x + x] = value;
                    }
                });
            });
        }

        function clearLines() {
            let linesCleared = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(value => value > 0)) {
                    linesCleared++;
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    y++;
                }
            }
            if (linesCleared > 0) {
                lines += linesCleared;
                const points = [0, 100, 300, 500, 800];
                score += points[linesCleared] * level;
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(100, 1000 - (level - 1) * 50);
                updateUI();
            }
        }
        
        function spawnNewPiece() {
            piece = nextPiece;
            piece.ctx = ctx;
            piece.x = Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2);
            piece.y = 0;

            const nextShapeIndex = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
            nextPiece = new Piece(SHAPES[nextShapeIndex], nextCtx);
            drawNextPiece();
            
            if (!isValidMove(piece)) {
                gameOver();
            }
        }
        
        function rotatePiece() {
            const clone = JSON.parse(JSON.stringify(piece));
            const shape = clone.shape;
            const N = shape.length;
            const newShape = Array(N).fill().map(() => Array(N).fill(0));
            
            for(let y = 0; y < N; y++) {
                for(let x = 0; x < N; x++) {
                    newShape[x][N - 1 - y] = shape[y][x];
                }
            }
            clone.shape = newShape;
            
            const testPositions = [0, 1, -1, 2, -2];
            for (const offset of testPositions) {
                clone.x = piece.x + offset;
                if (isValidMove(clone)) {
                    piece.move(clone);
                    return;
                }
            }
        }
        
        function hardDrop() {
            let p = { ...piece };
            while(isValidMove(p)) {
                piece.move(p);
                p.y++;
            }
            lockPiece();
            clearLines();
            spawnNewPiece();
            dropCounter = 0;
        }

        function updateUI() {
            scoreEl.textContent = score;
            bestScoreEl.textContent = bestScore;
            linesEl.textContent = lines;
            levelEl.textContent = level;
        }
        
        function gameOver() {
            isGameOver = true;
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            
            if(score > bestScore) {
                bestScore = score;
                localStorage.setItem('tetrisBestScore', bestScore);
                updateUI();
            }
            
            overlayTitle.textContent = "游戏结束";
            overlayText.textContent = `你的分数: ${score}`;
            startButton.textContent = "再玩一次";
            overlay.classList.remove('hidden');
        }

        function togglePause() {
            if(isGameOver) return;
            isPaused = !isPaused;
            if(isPaused) {
                if(animationFrameId) cancelAnimationFrame(animationFrameId);
                overlayTitle.textContent = "已暂停";
                overlayText.textContent = "按 P 键或点击按钮继续";
                startButton.textContent = "继续游戏";
                overlay.classList.remove('hidden');
            } else {
                overlay.classList.add('hidden');
                gameLoop();
            }
        }
        
        document.addEventListener('keydown', e => {
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
                return;
            }

            if(isPaused || isGameOver) return;

            let p = { ...piece };
            if (e.key === 'ArrowLeft') {
                p.x--;
                if(isValidMove(p)) piece.move(p);
            } else if (e.key === 'ArrowRight') {
                p.x++;
                if(isValidMove(p)) piece.move(p);
            } else if (e.key === 'ArrowDown') {
                pieceDrop();
            } else if (e.key === 'ArrowUp') {
                rotatePiece();
            } else if (e.key === ' ') {
                e.preventDefault();
                hardDrop();
            }
        });
        
        let touchStartX, touchStartY, touchMoved;
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchMoved = false;
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(isPaused || isGameOver) return;
            if(Math.abs(e.touches[0].clientX - touchStartX) > 10) touchMoved = true;
            
            const touchX = e.touches[0].clientX;
            const dx = touchX - touchStartX;
            if (Math.abs(dx) > BLOCK_SIZE) {
                let p = { ...piece };
                p.x += dx > 0 ? 1 : -1;
                if(isValidMove(p)) piece.move(p);
                touchStartX = touchX;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            if(isPaused || isGameOver) return;
            
            if (!touchMoved) {
                rotatePiece();
            } else {
                const touchEndY = e.changedTouches[0].clientY;
                const dy = touchEndY - touchStartY;
                if (dy > BLOCK_SIZE * 3) { 
                     hardDrop();
                } else if (dy > BLOCK_SIZE) {
                    pieceDrop();
                }
            }
        }, { passive: false });
        
        startButton.addEventListener('click', () => {
            if (isPaused) {
                togglePause();
            } else {
                play();
            }
        });

        function showStartScreen() {
            bestScoreEl.textContent = bestScore;
            overlayTitle.textContent = "俄罗斯方块";
            overlayText.textContent = "准备好挑战了吗？";
            startButton.textContent = "开始游戏";
            overlay.classList.remove('hidden');
        }
        
        window.onload = showStartScreen;
    </script>
</body>
</html>

